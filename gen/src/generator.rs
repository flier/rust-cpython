use std::path::Path;
use std::fs::OpenOptions;
use std::io::prelude::*;

use cargo::core::{Workspace, Package};
use cargo::util::Config;
use cargo::util::important_paths::find_root_manifest_for_wd;

use syntex_syntax::ast;
use syntex_syntax::ptr::P;
use syntex_syntax::codemap::DUMMY_SP;

use quote;

use super::errors::*;

#[derive(Debug, Clone)]
#[doc(hidden)]
pub struct GenerateOptions {
    manifest_path: Option<String>,
    packages: Vec<String>,
}

impl GenerateOptions {
    pub fn new() -> Self {
        Default::default()
    }
}

impl Default for GenerateOptions {
    fn default() -> Self {
        GenerateOptions {
            manifest_path: None,
            packages: Vec::new(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Generator {
    options: GenerateOptions,
}

impl Generator {
    pub fn new() -> Self {
        Generator { options: Default::default() }
    }

    pub fn manifest_path<T: Into<String>>(&mut self, path: T) -> &mut Self {
        self.options.manifest_path = Some(path.into());
        self
    }

    pub fn package<T: Into<String>>(&mut self, path: T) -> &mut Self {
        self.options.packages.push(path.into());
        self
    }

    pub fn generate(self) -> Result<Generated> {
        Generated::generate(self.options)
    }
}

#[derive(Debug, Clone)]
pub struct Generated {
    module: ast::Mod,
    attributes: Vec<ast::Attribute>,
}

impl Generated {
    fn generate(options: GenerateOptions) -> Result<Self> {
        let GenerateOptions { manifest_path, packages } = options;
        let config = Config::default()?;
        let root = find_root_manifest_for_wd(manifest_path, config.cwd())?;
        let workspace = Workspace::new(&root, &config)?;
        let packages = workspace.members()
            .filter(|ref p| packages.is_empty() || packages.contains(&String::from(p.name())));
        let items = packages.flat_map(|p| Generated::process_package(p)).collect();

        let module = ast::Mod {
            inner: DUMMY_SP,
            items: items,
        };

        Ok(Generated {
            module: module,
            attributes: Vec::new(),
        })
    }

    fn process_package(package: &Package) -> Vec<P<ast::Item>> {
        debug!("processing package {}", package.name());

        let mut items = Vec::new();

        items
    }

    pub fn write_to<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let file = OpenOptions::new().write(true).truncate(true).create(true).open(path)?;

        self.write(&file)?;

        Ok(())
    }

    fn write<W: Write>(&self, mut w: W) -> Result<()> {
        write!(w, "/* automatically generated by cpython-gen */\n\n")?;

        Ok(())
    }
}
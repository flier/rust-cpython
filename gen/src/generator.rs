use std::path::Path;
use std::fs::OpenOptions;
use std::io::prelude::*;

use cargo::core::{Workspace, Package};
use cargo::util::Config;

use syntex_syntax::ast;
use syntex_syntax::symbol::Symbol;
use syntex_syntax::ptr::P;
use syntex_syntax::codemap::DUMMY_SP;
use syntex_syntax::parse::{ParseSess, parse_crate_from_file};

use quote;

use super::errors::*;
use super::extractor::Extractor;

#[derive(Debug, Clone)]
#[doc(hidden)]
pub struct GenerateOptions {
    manifest_path: Option<String>,
    packages: Vec<String>,
}

impl GenerateOptions {
    pub fn new() -> Self {
        Default::default()
    }
}

impl Default for GenerateOptions {
    fn default() -> Self {
        GenerateOptions {
            manifest_path: None,
            packages: Vec::new(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Generator {
    options: GenerateOptions,
}

impl Generator {
    pub fn new() -> Self {
        Generator { options: Default::default() }
    }

    pub fn manifest_path<T: Into<String>>(&mut self, path: T) -> &mut Self {
        self.options.manifest_path = Some(path.into());
        self
    }

    pub fn package<T: Into<String>>(&mut self, path: T) -> &mut Self {
        self.options.packages.push(path.into());
        self
    }

    pub fn generate(&self) -> Result<Generated> {
        Generated::generate(&self.options)
    }
}

#[derive(Debug, Clone)]
pub struct Generated {
    module: ast::Mod,
    attributes: Vec<ast::Attribute>,
}

impl Generated {
    fn generate(options: &GenerateOptions) -> Result<Self> {
        let config = Config::default()?;
        let workspace = Extractor::find_workspace(options.manifest_path.clone(), &config)?;
        let packages = Extractor::find_packages(&workspace, &options.packages);

        let module = ast::Mod {
            inner: DUMMY_SP,
            items: packages.iter()
                .flat_map(|p| Generated::process_package(p))
                .flat_map(|p| p)
                .collect(),
        };

        Ok(Generated {
            module: module,
            attributes: Vec::new(),
        })
    }

    fn process_package(package: &Package) -> Result<Vec<P<ast::Item>>> {
        debug!("processing package `{}` @ {}",
               package.name(),
               package.root().to_str().unwrap());

        let targets = Extractor::find_targets(package.manifest(), "cdylib");
        let parse_session = ParseSess::new();

        for target in targets {
            debug!("parsing `cdylib` crate `{}` @ {}",
                   target.crate_name(),
                   target.src_path().to_str().unwrap());

            let c = parse_crate_from_file(target.src_path(), &parse_session)?;

            let py_classes = Extractor::find_classes(&c.module.items, Symbol::intern("PyClass"));

            for clazz in py_classes {
                if let Some(py_fields) = Extractor::find_fields(&clazz) {}

                let py_members = Extractor::find_members(&c.module.items, clazz);
            }
        }

        let mut items = Vec::new();

        Ok(items)
    }

    pub fn write_to<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let file = OpenOptions::new().write(true).truncate(true).create(true).open(path)?;

        self.write(&file)?;

        Ok(())
    }

    fn write<W: Write>(&self, mut w: W) -> Result<()> {
        write!(w, "/* automatically generated by cpython-gen */\n\n")?;

        Ok(())
    }
}